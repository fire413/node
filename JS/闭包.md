当一个函数被创建并传递或从另一个函数返回时，它会携带一个背包。背包中是函数声明时作用域内的所有变量。

```js
 1: function createCounter() {
 2:   let counter = 0
 3:   const myFunction = function() {
 4:     counter = counter + 1
 5:     return counter
 6:   }
 7:   return myFunction
 8: }
 9: const increment = createCounter()
10: const c1 = increment()
11: const c2 = increment()
12: const c3 = increment()
13: console.log('example increment', c1, c2, c3)
```

- 同上， 行1 - 8。我们在全局执行上下文中创建了一个新的变量createCounter，它得到了指定的函数定义。
- 同上，第9行。我们在全局执行上下文中声明了一个名为`increment`的新变量。
- 同上，第9行。我们需要调用`createCounter`函数并将其返回值赋给`increment`变量。
- 同上，行1 - 8。调用函数，创建新的本地执行上下文。
- 同上，第2行。在本地执行上下文中，声明一个名为`counter`的新变量并赋值为 0 。
- 行3 - 6。声明一个名为`myFunction`的新变量，变量在本地执行上下文中声明,变量的内容是另一个函数定义。如第4行和第5行所定义，现在我们还创建了一个闭包，并将其作为函数定义的一部分。闭包包含作用域中的变量，在本例中是变量`counter`(值为0)。
- 第7行。返回`myFunction`变量的内容,删除本地执行上下文。`myFunction`和`counter`不再存在。控制权交给了调用上下文，我们返回函数定义和它的闭包，闭包中包含了创建它时在作用域内的变量。
- 第9行。在调用上下文(全局执行上下文)中，`createCounter`返回的值被指定为`increment`，变量`increment`现在包含一个函数定义(和闭包),由createCounter返回的函数定义,它不再标记为`myFunction`，但它的定义是相同的,在全局上下文中，称为`increment`。
- 第10行。声明一个新变量(c1)。
- 继续第10行。查找变量`increment`，它是一个函数，调用它。它包含前面返回的函数定义,如第4-5行所定义的。(它还有一个带有变量的闭包)。
- 创建一个新的执行上下文，没有参数，开始执行函数。
- 第4行。counter = counter + 1，寻找变量 `counter`，在查找本地或全局执行上下文之前，让我们检查一下闭包，瞧，闭包包含一个名为`counter`的变量，其值为0。在第4行表达式之后，它的值被设置为1。它再次被储存在闭包里，闭包现在包含值为1的变量 `counter`。
- 第5行。我们返回`counter的值`，销毁本地执行上下文。
- 回到第10行。返回值(1)被赋给变量`c1`。
- 第11行。我们重复步骤10-14。这一次，在闭包中此时变量`counter`的值是1。它在第12步设置的，它的值被递增并以2的形式存储在递增函数的闭包中,c2被赋值为2。
- 第12行。重复步骤10-14,`c3`被赋值为3。
- 第13行。我们打印变量c1 c2和c3的值。