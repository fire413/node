# `['1', '2', '3'].map(parseInt)` what & why ?

结果为：[1,NaN,NaN]

```js
const intValue = parseInt(string[, radix]);
```

其中可选参数radix是一个指定基数的参数，该方法返回一个指定基数的整数。

**注意：** 在`radix`为 undefined，或者`radix`为 0 或者没有指定的情况下，JavaScript 作如下处理：

- 如果字符串 string 以"0x"或者"0X"开头, 则基数是16 (16进制).
- 如果字符串 string 以"0"开头, 基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript 5 规定使用10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出radix参数的值。
- 如果字符串 string 以其它任何值开头，则基数是10 (十进制)。

当 radix >0 && (radix>36 || radix < 2) 返回NAN 当 radix = 0 或没传即（radix=undefined）返回十进制。

当正常情况下，
 str左起第一个数一旦大于或者等于进制数radix，立马返回 NaN
 str左起第一个数一旦小于进制数radix，就去做运算，直到遇到一个大于等于radix，就不加了哈！
 如parseInt('4215213', 5)   // 111  1+2*5+4*\*25

例如：

```js
parseInt('1', 0);    // 1
parseInt('2', 1);    // NaN
parseInt('3', 2);   // 由于 2的二进制数是 0 和 1 组成的，所以要返回 NaN
parseInt('1222', 2)   //首位 1<2哎，  则 1
parseInt('213', 3);     // 2* 3 + 1 = 7;  简单的我会算
['10', '10', '10', '10', '10'].map(parseInt)
parseInt('10', 0);    //  10 无意义吧
parseInt('10', 1);    //  NaN   ’10‘ 的首位 1>=1啦！直接NaN
parseInt('10', 2);   //  1*2 + 0 = 2
parseInt('10', 3)   //   1*3 + 0 = 3
parseInt('10', 4);  //   1*4 + 0 = 4  
```

改进方案：

方法1：

```js
['1','2','3'].map(n=>parseInt(n))
```

方法2：

```js
['1','2','3'].map(Number)
```

js实现map方法：

```javascript
if (!Array.prototype.map) {
  Array.prototype.map = function(callback, thisArg) {

    var T, A, k;

    if (this == null) {
      throw new TypeError(" this is null or not defined");
    }

    // 1. 将O赋值为调用map方法的数组.
    var O = Object(this);

    // 2.将len赋值为数组O的长度.
    var len = O.length >>> 0;

    // 3.如果callback不是函数,则抛出TypeError异常.
    if (Object.prototype.toString.call(callback) != "[object Function]") {
      throw new TypeError(callback + " is not a function");
    }

    // 4. 如果参数thisArg有值,则将T赋值为thisArg;否则T为undefined.
    if (thisArg) {
      T = thisArg;
    }

    // 5. 创建新数组A,长度为原数组O长度len
    A = new Array(len);

    // 6. 将k赋值为0
    k = 0;

    // 7. 当 k < len 时,执行循环.
    while(k < len) {

      var kValue, mappedValue;

      //遍历O,k为原数组索引
      if (k in O) {

        //kValue为索引k对应的值.
        kValue = O[ k ];

        // 执行callback,this指向T,参数有三个.分别是kValue:值,k:索引,O:原数组.
        mappedValue = callback.call(T, kValue, k, O);

        // 返回值添加到新数组A中.
        A[ k ] = mappedValue;
      }
      // k自增1
      k++;
    }

    // 8. 返回新数组A
    return A;
  };      
}
```