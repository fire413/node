1.

```js
var b = 10;
(function b() {
  b = 20;
  console.log(b)
})()
```

结果为：ƒ b() {  b = 20;  console.log(b)}

分析：函数表达式与函数声明不同，上面是由括号括起来的，是一个函数表达式，函数名只在函数内部有效，函数b相当于一个const的常量。对于一个常量进行赋值，在strict模式下会报错，非strict会静默失败。先从函数内部找，再从函数外部找。

2.

```js
var obj = {
    '2': 3,
    '3': 4,
    'length': 2,
    'splice': Array.prototype.splice,
    'push': Array.prototype.push
}
obj.push(1)
obj.push(2)
console.log(obj)
```

结果为：

![image-20200918165346164](https://i.loli.net/2020/09/18/cKqpV8bRUWP4Yx5.png)

分析：`push`方法应该是根据数组的`length`来根据参数给数组创建一个下标为`length`的属性。

3.

```js
// example 1
var a={}, b='123', c=123;  
a[b]='b';
a[c]='c';  
console.log(a[b]);  // 'c'

---------------------
// example 2
var a={}, b=Symbol('123'), c=Symbol('123');  
a[b]='b';
a[c]='c';  
console.log(a[b]); // 'b'

---------------------
// example 3
var a={}, b={key:'123'}, c={key:'456'};  
a[b]='b';
a[c]='c';  
console.log(a[b]);  // c
```

结果：'c'、'b'、'c'

分析：键名会转成字符串，example1中c 的键名会被转换成字符串'123'，这里会把 b 覆盖掉。example3中，对象类型会调用 toString 方法转换成字符串 [object Object]。这里会把 b 覆盖掉。example2中，任何一个 Symbol 类型的值都是不相等的，所以不会覆盖掉 b。