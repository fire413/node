构造方法创建对象

```js
let person = new Object();
person.name = "Nicholas";
person.sayName = function() {
console.log(this.name);
};
```

现在更流行使用对象字面量创建对象

```js
let person = { name: "Nicholas" , sayName() { console.log(this.name); } };
```

对象属性也有一些内部特性，根据这些特性可以将属性分为：数据属性、访问器属性。（文章中使用[[]]来表示属性的内部特性）

数据属性有以下内部特性：

- [[Configurable]] ：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把 它改为访问器属性。默认情况下，所有直接定义在对象上的 属性的这个特性都是 true ，如前面的例子所示。 
- [[Enumberable]] ：表示属性是否可以通过 for-in 循 环返回。默认情况下，所有直接定义在对象上的属性的这个 特性都是 true ，如前面的例子所示。 
- [[Writable]] ：表示属性的值是否可以被修改。默认情 况下，所有直接定义在对象上的属性的这个特性都是 true ，如前面的例子所示。
-  [[Value]] ：包含属性实际的值。这就是前面提到的那个 读取和写入属性值的位置。这个特性的默认值为 undefined 。

根据上面的两种方法给对象添加的属性，其内部特性[[COnfigurable]]、[[Enumberable]]、[[Writable]]为true，[[Value]]为设定的值。而通过Object.defineProperty方法给对象添加的属性，其内部特性[[COnfigurable]]、[[Enumberable]]、[[Writable]]为false。

Object.defineProperty() 方法。这个方法接收3个参数： 要给其添加属性的对象、属性的名称和一个描述符对象。最后一 个参数，即描述符对象上的属性可以包含： configurable 、 enumerable 、 writable 和 value ，跟相关特性的名称一 一对应。根据要修改的特性，可以设置其中一个或多个值。

```js
let person = {}; Object.defineProperty(person, "name" , { writable: false, value: "Nicholas" }); console.log(person.name); // "Nicholas" 
person.name = "Greg"; 
console.log(person.name); // "Nicholas"
```

访问器属性有以下内部特性：

- [[Configurable]] ：表示属性是否可以通过 delete删除并重新定义，是否可以修改它的特性，以及是否可以把它改为数据属性。默认情况下，所有直接定义在对象上的属性的这个特性都是 true 。
- [[Enumerable]] ：表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是true。
- [[Get]] ：获取函数，在读取属性时调用。默认值为undefined 。
- [[Set]] ：设置函数，在写入属性时调用。默认值为undefined 。

访问器属性是不能直接定义的，必须使用 Object.defineProperty() 。

```js
let book = {
    year_: 2017,
    edition: 1
};
Object.defineProperty(book,"year", {
    get() {
    return this.year_;
    },
    set(newValue) {
        if (newValue > 2017) {
        this.year_ = newValue;
        this.edition += newValue - 2017;
        }
    }
});
book.year = 2018;
console.log(book.edition); // 2
```

 Object.defineProperties() ：定义多个属性。这个方 法可以通过多个描述符一次性定义多个属性。它接收两个参数：要为 之添加或修改属性的对象和另一个描述符对象，其属性与要添加或修 改的属性一一对应。

```js
let book = {};
Object.defineProperties(book, {
year_: {
	value: 2017
},
edition: {
	value: 1
},
year: {
    get() {
        return this.year_;
    },
    set(newValue) {
        if (newValue > 2017) {
            this.year_ = newValue;
            this.edition += newValue - 2017;
        }
    }
}
});
```

读取属性的特性

Object.getOwnPropertyDescriptor() 方法可以取 得指定属性的属性描述符。这个方法接收两个参数：属性所在的对象 和要取得其描述符的属性名。返回值是一个对象，对于访问器属性包 含 configurable 、 enumerable 、 get 和 set 属性，对于数 据属性包含 configurable 、 enumberable 、 writable 和 value 属性。

```js
let descriptor =Object.getOwnPropertyDescriptor(book,"year_");
console.log(descriptor.value); // 2017
console.log(descriptor.configurable); // false
console.log(typeof descriptor.get); //"undefined"
```

Object.getOwnPropertyDescriptors()

```js
console.log(Object.getOwnPropertyDescriptors(book));
// {
// edition: {
// configurable: false,
// enumerable: false,
// value: 1,
// writable: false
// },
// year: {
// configurable: false,
// enumerable: false,
// get: f(),
// set: f(newValue),
// },
// year_: {
// configurable: false,
// enumerable: false,
// value: 2019,
// writable: false
// }
// }
```

 Object.getOwnPropertyNames() 返回对象实例的 常规属性数组， Object.getOwnPropertySymbols() 返回 对象实例的符号属性数组。这两个方法的返回值彼此互斥。 Object.getOwnPropertyDescriptors() 会返回同时包含 常规和符号属性描述符的对象。 Reflect.ownKeys() 会返回 两种类型的键。 

```js
let s1 = Symbol('foo'), s2 = Symbol('bar'); 
let o = { [s1]: 'foo val' , [s2]: 'bar val' , baz: 'baz val' , qux: 'qux val' };
console.log(Object.getOwnPropertySymbols(o)); // [Symbol(foo), Symbol(bar)]
console.log(Object.getOwnPropertyNames(o)); // ["baz" , "qux"]
console.log(Object.getOwnPropertyDescriptors( o)); // {baz: {...}, qux: {...}, Symbol(foo): {...}, Symbol(bar): {...}} 
console.log(Reflect.ownKeys(o)); // ["baz" , "qux" , Symbol(foo), Symbol(bar)] 
```

合并对象

Object.assign() 方 法。这个方法接收一个目标对象和一个或多个源对象作为参数，然后 将每个源对象中可枚举（ Object.propertyIsEnumerable() 返 回 true ）和自有（ Object.hasOwnProperty() 返回 true ） 属性复制到目标对象。以字符串和符号为键的属性会被复制。对每个 符合条件的属性，这个方法会使用源对象上的 [[Get]] 取得属性的 值，然后使用目标对象上的 [[Set]] 设置属性的值。

