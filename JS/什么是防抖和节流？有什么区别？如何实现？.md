# 什么是防抖和节流？有什么区别？如何实现？

#### 防抖debounce：高频触发的事件，在指定的单位时间内，只响应最后一次，如果在指定时间再次触发，则重新计算时间。

非立即执行版：触发后函数不会立即执行，会在n秒之后才会执行

```js
function debounce(fn,delay){
      let context = this;
      console.log(context);
      let args = arguments;
      console.log(args)
      var timer;
      return function(){
        clearTimeout(timer);
        timer=setTimeout(()=>{
          fn.apply(context,args)
        },delay)   
      }
    }
```

立即执行版：触发后立即执行

```js
function debounce(fn,delay){
  let context=this;
  let args=arguments;
  var timer;
  return function(){
    let callnow=!timer;
    clearTimeout(timer);
      timer=setTimeout(()=>{
        timer=null
    },delay) 
      if(callnow){
        fn.apply(context,args)
      }
  }
}
```
合并版：

```js
 function debounce(fn,delay,immediate){
      let context=this;
      let args=arguments;
      var timer;
      return function(){
        let callnow=!timer;
        clearTimeout(timer);
        if(immediate){
          timer=setTimeout(()=>{
            timer=null
          },delay)
          if(callnow){
            fn.apply(context,args)
          }
        }else{
          timer=setTimeout(()=>{
            fn.apply(context,args)
          },delay) 
        }
      }
    }
```



#### 节流throttle：高频触发的事件，在指定的单位时间内，只响应第一次；

时间戳版：

```js
function throttle(fn,delay){
      var nowTime = +new Date()
      return function(){
        if(+new Date-nowTime>delay){
          fn.apply(this,arguments)
          nowTime=+newDate()
        }
      }
    }
```

定时器版：

```js
 function throttle(fn, delay) {
      let timer;
      return function() {
        let context = this;
        console.log(context);
        let args = arguments;
        console.log(args)
        if (!timer) {
          timer = setTimeout(() => {
            timer = null;
            fn.apply(context, args)
          }, delay)
        }
      }
    }
```

合并版：

```js
function throttle(fn, delay ,type) {
  if(type===1){
    var previous = 0;
  }else if(type===2){
    var timeout;
  }
  return function() {
    let context = this;
    let args = arguments;
    if(type===1){
      let now = Date.now();
      if (now - previous > delay) {
        fn.apply(context, args);
        previous = now;
      }
    }else if(type===2){
      if (!timeout) {
        timeout = setTimeout(() => {
          timeout = null;
          fn.apply(context, args)
        }, delay)
      }
    }
  }
}
```