## React开发环境的搭建

1.安装脚手架create-react-app ：`npm install -g create-react-app`

2.创建React项目

```
create-react-app demo01   //用脚手架创建React项目
cd demo01   //等创建完成后，进入项目目录
npm start   //预览项目，如果能正常打开，说明项目创建成功
```

## 3.项目目录介绍

![image-20201105151445320](https://i.loli.net/2020/11/05/b2cwUYPiqInao59.png)

![image-20201105152538192](https://i.loli.net/2020/11/05/kelvMuCbsYcO8np.png)

![image-20201106094206204](https://i.loli.net/2020/11/06/Qh7AFwREo2SVKId.png)

## 4.HelloWorld初识

构建项目自动生成的index入口文件

![image-20201106100553774](https://i.loli.net/2020/11/06/bDFeBwAvHcr3XQj.png)

App组件的编写

![image-20201106100724322](https://i.loli.net/2020/11/06/Onm2oFJKsNSja9P.png)

运行效果图

![image-20201106100847314](https://i.loli.net/2020/11/06/m78RFqaDnYzSVsy.png)

## 5.React中的JSX语法

JSX就是Javascript和XML结合的一种格式。React发明了JSX，可以方便的利用HTML语法来创建虚拟DOM，当遇到`<`，JSX就当作HTML解析，遇到`{`就当JavaScript解析.

JSX与js对比：

```jsx
// JSX语法
<ul className="my-list">
    <li>JSPang.com</li>
    <li>I love React</li>
</ul>
```

```js
// JS代码
var child1 = React.createElement('li', null, 'JSPang.com');
var child2 = React.createElement('li', null, 'I love React');
var root = React.createElement('ul', { className: 'my-list' }, child1, child2);
```

## 6.Fragment标签

render方法的返回里，最外层必须有一个标签包裹，否则会报错，但有时候最外层的标签会影响布局等情况，此时可以用Fragment标签来解决此问题，将最外层标签替换成Fragment标签，再去浏览器中查看时，就没有最外层标签的包裹了。

![image-20201106103143162](https://i.loli.net/2020/11/06/sHbBo48UklGvFeJ.png)

## 7.组件示例初步介绍

### setState方法

改变state中的值需要使用setState方法。注意：`this.setState({inputValue: e.target.value})`只改变state对象下的inputValue，state对象下的其他属性值不发生改变。

### 事件绑定

在JSX中给标签绑定事件要用“on+事件名称”的方式绑定

自定义组件首字母必须大写

```jsx
import React, {Component, Fragment} from 'react'
class XiaoJieJie extends Component{
  constructor(props){
​    super(props)
​    this.state={
​      inputValue: "",
​      list: ['头部按摩','精油推拿']
​    }
  }
  inputChange(e){
   this.setState({
​    inputValue: e.target.value
   })
  }
  btnClick(){
   this.setState({
​    list: [...this.state.list,this.state.inputValue]
   })
  }
 render(){
  return (
   <Fragment>
        <div><input value={this.state.inputValue} onChange={this.inputChange.bind(this)}/><button onClick={this.btnClick.bind(this)}>添加服务</button></div>
​    <ul>
​     {
​      this.state.list.map((item,index)=>{
​       return <li key={item+index}>{item}</li>
​      })
​     }
​    </ul>
   </Fragment>
  )}
}
export default XiaoJieJie;
```

### JSX代码注释

有以下两种方法：

```jsx
{/* 正确注释的写法 */}
```

```jsx
 { //正确注释的写法 }
```

### dangerouslySetInnerHTML属性

可以实现html格式的输出

```js
render(){
  return (
   <Fragment>
        <div><input className="input" value={this.state.inputValue} onChange={this.inputChange.bind(this)}/><button onClick={this.btnClick.bind(this)}>添加服务</button></div>
​    <ul>
​     {
​      this.state.list.map((item,index)=>{
​       return <li key={item+index} onClick={this.deleteItem.bind(this,index)} dangerouslySetInnerHTML={{__html:item}}></li>
​      })
​     }
​    </ul>
   </Fragment>
  )
 }
```

### JSX中的`<label>`标签的注意点

一般来说，在html中，在表单中添加`<label>`标签，给标签添加属性for，再给文本框添加id属性，就可以激活文本框。但JSX中为区别javascript中for循环关键字，采用htmlFor属性。

```jsx
        <div>
    <label htmlFor="addItem">加入服务</label>
    <input id="addItem" className="input" value={this.state.inputValue} onChange=		{this.inputChange.bind(this)}/>
    <button onClick={this.btnClick.bind(this)}>添加服务</button></div>
```

## 8.Simple React Snippets插件

快速生成代码块插件

安装：在VScode中的Extensions中查询Simple React Snippets，点击安装即可。

**输入`imrc`生成如下代码:**

```js
import React, { Component } from 'react';
```

**输入`cc`生成如下代码:**

```js
class Test extends Component {
  state = {  }
  render() { 
    return ( <div></div> );
  }
}
export default Test;
```

**输入`impt`生成如下代码:**

```js
import PropTypes from 'prop-types';
```

**输入`ccc`生成如下代码:**

```js
class  extends Component {
  constructor(props) {
    super(props);
    this.state = {  }
  }
  render() { 
    return (  );
  }
} 
export default ;
```

**输入`sfc`生成如下代码:**

```js
const  = () => {
  return (  );
}
export default ;
```

**输入`cdm`生成如下代码:**

```js
componentDidMount() { 
}
```

**输入`cwm`生成如下代码:**

```js
//WARNING! To be deprecated in React v17. Use componentDidMount instead.
componentWillMount() {
  
}
```

**输入`cwrp`生成如下代码:**

```js
//WARNING! To be deprecated in React v17. Use new lifecycle static getDerivedStateFromProps instead.
componentWillReceiveProps(nextProps) {
  
}
```

**输入`gds`生成如下代码:**

```js
static getDerivedStateFromProps(nextProps, prevState) {
}
```

**输入`scu`生成如下代码:**

```js
shouldComponentUpdate(nextProps, nextState) {
}
```

**输入`cwu`生成如下代码:**

```js
//WARNING! To be deprecated in React v17. Use componentDidUpdate instead.
componentWillUpdate(nextProps, nextState) { 
}
```

**输入`cdu`生成如下代码:**

```js
componentDidUpdate(prevProps, prevState) {
}
```

**输入`cdc`生成如下代码:**

```js
componentDidCatch(error, info) {
}
```

**输入`gsbu`生成如下代码:**

```js
getSnapshotBeforeUpdate(prevProps, prevState) {}
```

**输入`ss`生成如下代码:**

```js
this.setState({ :  });
```

**输入`ssf`生成如下代码:**

```js
this.setState(prevState => {
  return { : prevState. };
});
```

**输入`ren`生成如下代码:**

```js
render() {
  return (    
  );
}
```

**输入`rprop`生成如下代码:**

```jsx
class  extends Component {
  state = { :  }
  render() { 
    return this.props.render({
      : this.state.
    });
  }
}
export default ;
```

**输入`hoc`生成如下代码:**

```jsx
function () {
  return class extends Component {
    constructor(props) {
      super(props);
    }
    render() {
      return < {...this.props} />
    }
  }
}
```

## 9.父子组件传值

**父组件向子组件传值**

父组件向子组件传值，直接给子组件上加上需要传递的属性，并赋值，子组件利用this.props.xxx来接收。

```jsx
<div><XiaoJieJieItem content={item}/></div>
```

```jsx
class XiaoJieJieItem extends Component {
    state = {  }
    render() { 
    return ( <div>{this.props.content}</div> );
    }
}
```

## 10.PropTypes

```js
XiaoJieJieItem.propTypes={
  content:PropTypes.string.isRequired,
  deleteItem:PropTypes.func,
  index:PropTypes.number.isRequired  // isRequired表示必传该属性
}
XiaoJieJieItem.defaultProps = {  // 设置默认值
    content:'小姐姐'
}
```

## 11.ref的使用

```jsx
<input 
    id="jspang" 
    className="input" 
    value={this.state.inputValue} 
    onChange={this.inputChange.bind(this)}
    //关键代码——----------start
    ref={(input)=>{this.input=input}}
    //关键代码------------end
    />
```

## 12.生命周期

React声明周期的四大阶段：

Initialization：初始化阶段

Mounting：挂载阶段

Updation：更新阶段

Unmounting：销毁阶段

注意：constructor不是生命周期函数。

**Mounting挂载阶段**

伴随着整个虚拟DOM的生成里面有三个小生命周期函数，分别是：

*componentWillMount*：在组件即将被挂载到页面的时候执行

*render*：页面states或props发生变化时执行

*componentDidMount*：组件挂载完成时被执行

注意：componentWillMount与componentDidMount只在页面刷新时执行一次，而render函数只要有states或者props的变化，就会执行。

**Updation更新阶段**

*shouldComponentUpdate（newProps,newState）*：两个参数：newProps变化后的属性，newState变化后的状态；函数在组件更新之前自动执行，该函数必须要有返回值，返回值为布尔类型。返回true，同意组件更新，返回false，反对组件更新。

*componentWillUpdate*：在组件更新之前，但在shouldComponentUpdate之后执行，如果shouldComponentUpdate返回false，就不执行了。

*componentDidUpdate*：在组件更新之后执行，它是组件更新的最后一个环节

*componentWillReceiveProps*：接收props时执行。子组件接收到父组件传递过来的参数，父组件render函数重新被执行，这个生命周期就会被执行。

**Unmounting销毁阶段**

*componentWillUnmount*：组件从页面中删除时执行

## 13.React中的动画

安装React中第三方动画组件库React-transition-group

包含三个核心组件库

Transition

CSSTransition

TransitinGroup

CSSTransition有以下类样式：

- xxx-enter: 进入（入场）前的CSS样式；
- xxx-enter-active:进入动画直到完成时之前的CSS样式;
- xxx-enter-done:进入完成时的CSS样式;
- xxx-exit:退出（出场）前的CSS样式;
- xxx-exit-active:退出动画知道完成时之前的的CSS样式。
- xxx-exit-done:退出完成时的CSS样式。

# Redux

Redux是一个用来管理管理数据状态和UI状态的JavaScript应用工具。

![image-20201201145134410](C:\Users\ZC\AppData\Roaming\Typora\typora-user-images\image-20201201145134410.png)

## Ant Design

Ant Design`是一套面向企业级开发的UI框架，视觉和动效作的很好。阿里开源的一套UI框架，它不只支持`React`，还有`ng`和`Vue`的版本，我认为不论你的前端框架用什么，`Ant Design`都是一个不错的选择。习惯性把`AntDesign`简称为`antd。

1.安装：npm install antd --save

2.在需要ui组件的组件文件里引入所需的ui组件即可（注意引入antd.css文件）

```js
import 'antd/dist/antd.css';
import {Input,Button,List} from 'antd'
```

## redux中的仓库-store和reducer

创建store仓库

1.安装 npm install --save redux

安装好后再src目录下创建store文件夹，在该文件加下创建index.js文件。

```js
import { createStore } from 'redux'  // 引入createStore方法
import reducer from './reducer'  // 引入reducer模块
const store = createStore(reducer)          // 创建数据存储仓库
export default store                 //暴露出去
```

2.创建Reducers模块

在store目录下创建reducer.js文件

```js
const defaultState = {}  //默认数据
export default (state = defaultState,action)=>{  //就是一个方法函数
    return state
}
```

3.`src/TodoList.js`文件中的使用

```jsx
import store from './store'
class TodoList extends Component {
constructor(props){
    super(props)
    //关键代码-----------start
    this.state=store.getState();
    //关键代码-----------end
    console.log(this.state)
}
    render() { 
        return ( 
            <div style={{margin:'10px'}}>
                <div>
                    <Input placeholder={this.state.inputValue} style={{ width:'250px', marginRight:'10px'}}/>
         );
    }
}
export default TodoList;
```

## Redux DevTools

在谷歌应用商店查询安装Redux DevTools插件，代码中在`store/index.js`中配置该插件

```js
import { createStore } from 'redux'  //  引入createStore方法
import reducer from './reducer'    
const store = createStore(reducer,
window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()) // 创建数据存储仓库
export default store   //暴露出去
```

## Redux整体流程

通过一个小例子展示：

在文本输入框中输入文本，触发onChange事件,改变文本值。

页面一开始通过`import store from './store'`，使用store.getState()，将值赋给该组件的state，此时文本框有了默认的值，给文本框input添加onChange触发事件，将改变后的值通过store.dispatch(action)方法，进入到reducer.js中，在reducer.js中通过业务逻辑判断，重新更新store中的state的值，TodoList.js中通过在构造函数中store.subscribe()方法，订阅Redux的状态，使页面组件随着store的变化而发生同步变化。

```jsx
// src/TodoList.js
import React, { Component } from 'react';
import 'antd/dist/antd.css'
import { Input , Button , List } from 'antd'
import store from './store'
class TodoList extends Component {
    constructor(props){
        super(props)
        this.state=store.getState();  // 通过getState方法获取store中的数据
        this.changeInputValue= this.changeInputValue.bind(this)
        store.subscribe(this.storeChange) //订阅Redux的状态  让组件自动更新
    }
    render() { 
        return ( 
            <div style={{margin:'10px'}}>
                <div>
                    <Input 
                        placeholder={this.state.inputValue} 
                        style={{ width:'250px', marginRight:'10px'}}
                        onChange={this.changeInputValue}
                    />
                    <Button type="primary">增加</Button>
                </div>
                <div style={{margin:'10px',width:'300px'}}>
                    <List
                        bordered
                        dataSource={this.state.list}
                        renderItem={item=>(<List.Item>{item}</List.Item>)}
                    />    
                </div>
            </div>
         );
    }
    changeInputValue(e){
    const action ={
        type:'changeInput',
        value:e.target.value
    }
    store.dispatch(action)
}
    storeChange(){
         this.setState(store.getState())
     }
}
export default TodoList;
```

注意：**Reducer里只能接收state，不能改变state。**

```js
// store/reducer.js
// state: 指的是原始仓库里的状态。
// action: 指的是action新传递的状态。
export default (state = defaultState,action)=>{
    if(action.type === 'changeInput'){
        let newState = JSON.parse(JSON.stringify(state)) //深度拷贝state
        newState.inputValue = action.value
        return newState
    }
    return state
}
```

注意：

- `store`必须是唯一的，多个`store`是坚决不允许，只能有一个`store`空间
- 只有`store`能改变自己的内容，`Reducer`不能改变
- `Reducer`必须是纯函数

## redux-thunk与redux-sage中间件

在`Dispatch`一个`Action`之后，到达`reducer`之前，进行一些额外的操作，就需要用到`middleware`（中间件）。在实际工作中你可以使用中间件来进行日志记录、创建崩溃报告，调用异步接口或者路由。 

1.Redux-thunk组件

安装：npm install --save redux-thunk

配置：

引入`applyMiddleware`,如果你要使用中间件，就必须在redux中引入`applyMiddleware`.

引入`redux-thunk`库

```js
import { createStore , applyMiddleware ,compose } from 'redux'  //  引入createStore方法，增强函数compose
import reducer from './reducer'    
import thunk from 'redux-thunk'

const composeEnhancers =   window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ?
    window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({}):compose

const enhancer = composeEnhancers(applyMiddleware(thunk))

const store = createStore( reducer, enhancer) // 创建数据存储仓库
export default store   //暴露出去
```

`store/actionCreatores.js`文件中处理业务逻辑。

2.Redux-saga组件

安装：npm install --save redux-saga

配置：

```js
import { createStore , applyMiddleware ,compose } from 'redux'  //  引入createStore方法
import reducer from './reducer'   
import createSagaMiddleware from 'redux-saga' 
import mySagas from './sagas' 

const sagaMiddleware = createSagaMiddleware();

const composeEnhancers =   window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ?
    window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({}):compose
const enhancer = composeEnhancers(applyMiddleware(sagaMiddleware))
const store = createStore( reducer, enhancer) 
sagaMiddleware.run(mySagas)  // 运行saga

export default store  
```

`redux-saga`希望你把业务逻辑单独写一个文件，这里我们在`/src/store/`文件夹下建立一个`sagas.js`文件。

```js
function* mySaga() {} 
export default mySaga;
```

## React-Redux

注意：redux-thunk与redux-saga是redux的中间件，React-Redux是React的中间件。

作用：简化Redux操作流程。

Provider提供器

`<Provider>`是一个提供器，只要使用了这个组件，组件里边的其它所有组件都可以使用`store`了，这也是`React-redux`的核心组件了。

```jsx
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';
import { Provider } from 'react-redux'
import store from './store'

ReactDOM.render(
  <Provider store={store}>
    <App />
    </Provider>,
  document.getElementById('root')
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();
```

connect连接器

```jsx
import React, { Component } from 'react';
import store from './store'
import {connect} from 'react-redux'

class TodoList extends Component {
    constructor(props){
        super(props)
        this.state = store.getState()
    }
    render() { 
        return (
            <div>
                <div>
                    <input value={this.props.inputValue} onChange={this.props.inputChange} />
                    <button>提交</button>
                </div>
                <ul>
                    <li>JSPang</li>
                </ul>
            </div>
            );
    }
}
const stateToProps = (state)=>{  // 映射
    return {
        inputValue : state.inputValue
    }
}

const dispatchToProps = (dispatch) =>{  //映射
    return {
        inputChange(e){
            console.log(e.target.value)
        }
    }
}

export default connect(stateToProps,dispatchToProps)(TodoList);
```

# React-Router

安装：npm install --save react-router-dom

![image-20201215101730391](C:\Users\ZC\AppData\Roaming\Typora\typora-user-images\image-20201215101730391.png)

src/AppRouter2.js

```jsx
// import React, { Component } from 'react';
import {BrowserRouter as Router,Link,Route} from 'react-router-dom'
import './AppRouter2.css'
import Home from './Home.js'
import Video from './Pages/Video'
import Workplace from './Pages/Workplace'
let routeConfig =[
  {path:'/',title:'博客首页',exact:true,component:Home},
  {path:'/video/',title:'视频教程',exact:false,component:Video},
  {path:'/workplace/',title:'职场技能',exact:false,component:Workplace}
]
function AppRouter2(){
  return (
​    <Router>
          <div className="mainDiv">
            <div className="leftNav">
​        <h3>一级导航</h3>
​        <ul>
​          {
​            routeConfig.map(item=>{
​            return (<li> <Link to={item.path}>{item.title}</Link> </li>)
​            })
​          }
​        </ul>
​      </div>
            <div className="rightMain">
​        {
​          routeConfig.map(item=>{
​            return (<Route path={item.path} exact={item.exact} component={item.component} /> )
​          })
​        }
​      </div>
​     </div>
   </Router>
  )
}
export default AppRouter2;
```

传值：

src/AppRouter.js

```jsx
import React from "react";
import { BrowserRouter as Router, Route, Link } from "react-router-dom";
import Index from './Pages/Index'
import List from './Pages/List'

function AppRouter() {
  return (
    <Router>
        <ul>
            <li> <Link to="/">首页</Link> </li>
            <li><Link to="/list/123">列表</Link> </li>
        </ul>
        <Route path="/" exact component={Index} />
        <Route path="/list/:id" component={List} />
    </Router>
  );
}

export default AppRouter;
```

接收：

```jsx
import React, { Component } from 'react';

class List extends Component {
    constructor(props) {
        super(props);
        this.state = {  }
    }
    render() { 
        return (  <h2>List Page->{this.state.id}</h2> );
    }
    componentDidMount(){
       // console.log(this.props.match.params.id)
       let tempId=this.props.match.params.id
        this.setState({id:tempId })
    }
}
//this.props.match  打印出：
//patch:自己定义的路由规则，可以清楚的看到是可以产地id参数的。
//url: 真实的访问路径，这上面可以清楚的看到传递过来的参数是什么。
//params：传递过来的参数，key和value值。

export default List;
```

# React Hooks

`React Hooks`就是用函数的形式代替原来的继承类的形式，并且使用预函数的形式管理`state`，有Hooks可以不再使用类的形式定义组件了。这时候你的认知也要发生变化了，原来把组件分为有状态组件和无状态组件，有状态组件用类的形式声明，无状态组件用函数的形式声明。那现在所有的组件都可以用函数来声明了。

## useState

```jsx
//useState`是react自带的一个hook函数，它的作用是用来声明状态变量。
import React, { useState, useEffect} from 'react';
// useState是react自带的一个hook函数，它的作用是用来声明状态变量
// react Hooks不能出现在条件判断语句中，因为它必须有完全一样的渲染顺序。
function Example(){
  const [count,setCount]=useState(0)
  return (
        <div>
            <p>You Clicked {count} times</p>
​      <button onClick={()=>{setCount(count+1)}}>click me</button>
​    </div>
  )
}
export default Example;
```

## useEffect

useEffect函数替代声明周期函数componentDidMonut和componentDidUpdate

```jsx
import React, { useState , useEffect } from 'react';
function Example(){
    const [ count , setCount ] = useState(0);
    //---关键代码---------start-------
    useEffect(()=>{
        console.log(`useEffect=>You clicked ${count} times`)
    })
    //---关键代码---------end-------
    //结果：
    //刚开始渲染打印useEffect=>You clicked 0 times
    //之后每次更新重新渲染打印
    //useEffect=>You clicked 1 times
    //useEffect=>You clicked 2 times
    //.。。

    return (
        <div>
            <p>You clicked {count} times</p>
            <button onClick={()=>{setCount(count+1)}}>click me</button>
        </div>
    )
}
export default Example;
```

注意点：

1. React首次渲染和之后的每次渲染都会调用一遍`useEffect`函数，而之前我们要用两个生命周期函数分别表示首次渲染(componentDidMonut)和更新导致的重新渲染(componentDidUpdate)。
2. useEffect中定义的函数的执行不会阻碍浏览器更新视图，也就是说这些函数时异步执行的，而`componentDidMonut`和`componentDidUpdate`中的代码都是同步执行的。个人认为这个有好处也有坏处吧，比如我们要根据页面的大小，然后绘制当前弹出窗口的大小，如果时异步的就不好操作了。

useEffect替代componentWillUnmount进行解绑

```jsx
function Example(){
    const [ count , setCount ] = useState(0);

    useEffect(()=>{
        console.log(`useEffect=>You clicked ${count} times`)

        return ()=>{
            console.log('====================')
        }   // 返回一个函数进行解绑，相当于componentWillUnmount
    },[])  // 第二个参数传空数组表示当组件被销毁时才进行解绑
    //第二个参数，它是一个数组，数组中可以写入很多状态对应的变量，意思是当状态值发生变化时，我们才进行解绑。
	// 比如写入[count]
    return (
        <div>
            <p>You clicked {count} times</p>
            <button onClick={()=>{setCount(count+1)}}>click me</button>

            <Router>
                <ul>
                    <li> <Link to="/">首页</Link> </li>
                    <li><Link to="/list/">列表</Link> </li>
                </ul>
                <Route path="/" exact component={Index} />
                <Route path="/list/" component={List} />
            </Router>
        </div>
    )
}
```

## useContext

使用useContext实现父子传值，它可以帮助我们跨越组件层级直接传递变量，实现共享。

```jsx
import React, { useState , createContext } from 'react';
//===关键代码
const CountContext = createContext()

function Counter(){
    const count = useContext(CountContext)  //一句话就可以得到count
    return (<h2>{count}</h2>)
}

function Example4(){
    const [ count , setCount ] = useState(0);

    return (
        <div>
            <p>You clicked {count} times</p>
            <button onClick={()=>{setCount(count+1)}}>click me</button>
            {/*======关键代码 */}
            <CountContext.Provider value={count}>
    			<Counter />
			</CountContext.Provider>
        </div>
    )
}
export default Example4;
```

## useReducer

`useReducer`可以让代码具有更好的可读性和可维护性，并且会给测试提供方便。

```jsx
import React, { useReducer } from 'react';

function ReducerDemo(){
    const [ count , dispatch ] =useReducer((state,action)=>{
        switch(action){
            case 'add':
                return state+1
            case 'sub':
                return state-1
            default:
                return state
        }
    },0)
    return (
       <div>
           <h2>现在的分数是{count}</h2>
           <button onClick={()=>dispatch('add')}>Increment</button>
           <button onClick={()=>dispatch('sub')}>Decrement</button>
       </div>
    )

}

export default ReducerDemo
```

使用useContext与useReducer实现类似Redux的效果

`useContext`：可访问全局状态，避免一层层的传递状态。这符合`Redux`其中的一项规则，就是状态全局化，并能统一管理。

`useReducer`：通过action的传递，更新复杂逻辑的状态，主要是可以实现类似`Redux`中的`Reducer`部分，实现业务逻辑的可行性。

```jsx
//Example7.js  父组件 引入Color使数据共享，实现父子传值
import ShowArea from './ShowArea'
import Button from './Button'
import Color from './color'
function Example7(){
  return(
        <div>
​      <Color>
​        <ShowArea></ShowArea>
​        <Button></Button>
​      </Color>
​    </div>
  )
}
export default Example7;
```

```jsx
// ShowArea.js  子组件 使用useContext接收数据
import { useContext } from 'react';
import {ColorContext} from './color'
function ShowArea(){
    const {color} = useContext(ColorContext)
    console.log(useContext(ColorContext))
    return(
        <div style={{color:color}}>字体颜色为{color}</div>
    )
}
export default ShowArea
```

```jsx
// Button.js 子组件 使用useContext接收数据
import { useContext } from 'react';
import {ColorContext} from './color'
function Button(){
    const {dispatch} = useContext(ColorContext)
    return(
        <div>
            <button onClick={()=>{dispatch('red')}}>红色</button>
            <button onClick={()=>{dispatch('green')}}>绿色</button>
        </div>
    )
}
export default Button;
```

```jsx
// color.js 用于共享全局状态  使用useReducer，更新复杂逻辑的状态
import React,{createContext,useReducer} from 'react'
export const ColorContext=createContext()

function Color(props){
    const [color,dispatch]=useReducer((state,action)=>{
        switch(action){
            case 'red': 
                return 'red';
            case 'green':
                return 'green';
            default:
                return state
        }
    },'blue')
    return(
<ColorContext.Provider
    value={{color,dispatch}}
    >
        {props.children}
    </ColorContext.Provider>
    )   
}
export default Color
```

## useMemo

`useMemo`主要用来解决使用React hooks产生的无用渲染的性能问题。

```jsx
//Father.js
import {useState} from 'react'
import Son from './Son'
function Father(){
  const [title,setTitle]=useState('标题');
  const [content,setContent]=useState("内容");
  return(
        <div>
​      <button onClick={()=>{setTitle(new Date().getTime())}}>title</button>
​      <button onClick={()=>{setContent(new Date().getTime())}}>content</button>
​      <Son name={title}>{content}</Son>
​    </div>
  )
}
export default Father;
```

```jsx
// Son.js
import {useMemo} from 'react'
function Son(props){
  const actionXiaohong = useMemo(()=>((name)=>name)(props.name),[props.name]) 
  console.log(actionXiaohong)
  return(
        <div>
            <div>{actionXiaohong}</div>
            <div>{props.children}</div>
​    </div>
  )
}
export default Son;
```

useRef

用`useRef`获取React JSX中的DOM元素，获取后你就可以控制DOM的任何东西了。但是一般不建议这样来作，React界面的变化可以通过状态来控制。

# npm安装问题

- `npm install xxx`: 安装项目到项目目录下，不会将模块依赖写入`devDependencies`或`dependencies`。
- `npm install -g xxx`: `-g`的意思是将模块安装到全局，具体安装到磁盘哪个位置，要看 `npm cinfig prefix`的位置
- `npm install -save xxx`：`-save`的意思是将模块安装到项目目录下，并在`package`文件的`dependencies`节点写入依赖。
- `npm install -save-dev xxx`：`-save-dev`的意思是将模块安装到项目目录下，并在`package`文件的`devDependencies`节点写入依赖。

easy-mock：在线模拟后台数据的平台。通过在官网注册一个账号，就可以在线生成一个API了。